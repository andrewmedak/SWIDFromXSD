//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace org.w3.xml {
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.IO;
    using System.Linq;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.Schema;
    using System.Xml.Linq;
    using Xml.Schema.Linq;
    using org.iso.standards.swid;
    
    
    public sealed class lang {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.UnionSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyAtomicType), null, new Xml.Schema.Linq.SimpleTypeValidator[] {
                    new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Language), null),
                    new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                                    ""}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve))});
        
        private lang() {
        }
    }
}
namespace org.iso.standards.swid {
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.IO;
    using System.Linq;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.Schema;
    using System.Xml.Linq;
    using Xml.Schema.Linq;
    using org.w3.xml;
    
    
    /// <summary>
    /// <para>
    /// 
    ///        Attributes common to all Elements in this schema
    ///      
    /// </para>
    /// </summary>
    public partial class BaseElement : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName langXName = System.Xml.Linq.XName.Get("lang", "http://www.w3.org/XML/1998/namespace");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("BaseElement", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd");
        
		public static explicit operator BaseElement(XElement xe) { return XTypedServices.ToXTypedElement<BaseElement>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        /// <summary>
        /// <para>
        /// 
        ///        Attributes common to all Elements in this schema
        ///      
        /// </para>
        /// </summary>
        public BaseElement() {
        }
        
        /// <summary>
        /// <para>
        /// 
        ///          Allow xml:lang attribute on any element.
        ///        
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual object lang {
            get {
                XAttribute x = this.Attribute(langXName);
                return XTypedServices.ParseUnionValue(x, null);
            }
            set {
                this.SetUnionAttribute(value, "lang", this, langXName, null);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<BaseElement>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    /// <summary>
    /// <para>
    /// Regular expression: (Meta)*
    /// </para>
    /// </summary>
    public partial class Entity : global::org.iso.standards.swid.BaseElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName MetaXName = System.Xml.Linq.XName.Get("Meta", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<Meta> MetaField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName nameXName = System.Xml.Linq.XName.Get("name", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName regidXName = System.Xml.Linq.XName.Get("regid", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static System.Uri regidDefaultValue = new Uri("http://invalid.unavailable");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName roleXName = System.Xml.Linq.XName.Get("role", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName thumbprintXName = System.Xml.Linq.XName.Get("thumbprint", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("Entity", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator Entity(XElement xe) { return XTypedServices.ToXTypedElement<Entity>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static Entity() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(MetaXName));
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (Meta)*
        /// </para>
        /// </summary>
        public Entity() {
        }
        
        /// <summary>
        /// <para>
        /// 
        ///                An open-ended collection of elements that can be used to attach
        ///                arbitrary metadata to an Entity.
        ///              
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// <para>
        /// Regular expression: (Meta)*
        /// </para>
        /// </summary>
        public virtual IList<Meta> Meta {
            get {
                if ((this.MetaField == null)) {
                    this.MetaField = new XTypedList<Meta>(this, LinqToXsdTypeManager.Instance, MetaXName);
                }
                return this.MetaField;
            }
            set {
                if ((value == null)) {
                    this.MetaField = null;
                }
                else {
                    if ((this.MetaField == null)) {
                        this.MetaField = XTypedList<Meta>.Initialize(this, LinqToXsdTypeManager.Instance, value, MetaXName);
                    }
                    else {
                        XTypedServices.SetList<Meta>(this.MetaField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              The name of the organization claiming a particular role in the
        ///              SWID tag.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string name {
            get {
                XAttribute x = this.Attribute(nameXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(nameXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              The regid of the organization.  If the regid is unknown, the
        ///              value "invalid.unavailable" is provided by default (see
        ///              RFC 6761 for more details on the default value).
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual System.Uri regid {
            get {
                XAttribute x = this.Attribute(regidXName);
                return XTypedServices.ParseValue<System.Uri>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyUri).Datatype, regidDefaultValue);
            }
            set {
                this.SetAttribute(regidXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyUri).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              The relationship between this organization and this tag e.g. tag,
        ///              softwareCreator, licensor, tagCreator, etc.  The role of
        ///              tagCreator is required for every SWID tag.
        ///
        ///              EntityRole may include any role value, but the pre-defined roles
        ///              include: aggregator, distributor, licensor, softwareCreator,
        ///              tagCreator
        ///
        ///              Other roles will be defined as the market uses the SWID tags.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual IList<string> role {
            get {
                XAttribute x = this.Attribute(roleXName);
                return XTypedServices.ParseListValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
            }
            set {
                this.SetListAttribute(roleXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              this value provides a hexadecimal string that contains a hash
        ///              (or thumbprint) of the signing entities certificate.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string thumbprint {
            get {
                XAttribute x = this.Attribute(thumbprintXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(thumbprintXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<Entity>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(MetaXName, typeof(Meta));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    /// <summary>
    /// <para>
    /// Regular expression: (Directory | File | Process | Resource)*
    /// </para>
    /// </summary>
    public partial class Evidence : global::org.iso.standards.swid.ResourceCollection, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName dateXName = System.Xml.Linq.XName.Get("date", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName deviceIdXName = System.Xml.Linq.XName.Get("deviceId", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("Evidence", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator Evidence(XElement xe) { return XTypedServices.ToXTypedElement<Evidence>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static Evidence() {
            BuildElementDictionary();
            contentModel = new ChoiceContentModelEntity(new NamedContentModelEntity(DirectoryXName), new NamedContentModelEntity(FileXName), new NamedContentModelEntity(ProcessXName), new NamedContentModelEntity(ResourceXName));
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (Directory | File | Process | Resource)*
        /// </para>
        /// </summary>
        public Evidence() {
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              Date and time the evidence was gathered.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual System.DateTime? date {
            get {
                XAttribute x = this.Attribute(dateXName);
                if ((x == null)) {
                    return null;
                }
                return XTypedServices.ParseValue<System.DateTime>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.DateTime).Datatype);
            }
            set {
                this.SetAttribute(dateXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.DateTime).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              Identifier for the device the evidence was gathered from.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string deviceId {
            get {
                XAttribute x = this.Attribute(deviceIdXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(deviceIdXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<Evidence>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(DirectoryXName, typeof(Directory));
            localElementDictionary.Add(FileXName, typeof(File));
            localElementDictionary.Add(ProcessXName, typeof(Process));
            localElementDictionary.Add(ResourceXName, typeof(Resource));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    public partial class FilesystemItem : global::org.iso.standards.swid.Meta, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName keyXName = System.Xml.Linq.XName.Get("key", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName locationXName = System.Xml.Linq.XName.Get("location", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName nameXName = System.Xml.Linq.XName.Get("name", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName rootXName = System.Xml.Linq.XName.Get("root", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("FilesystemItem", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd");
        
		public static explicit operator FilesystemItem(XElement xe) { return XTypedServices.ToXTypedElement<FilesystemItem>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public FilesystemItem() {
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              Files that are considered important or required for the use of
        ///              a software component.  Typical key files would be those which,
        ///              if not available on a system, would cause the software not to
        ///              execute.
        ///
        ///              Key files will typically be used to validate that software
        ///              referenced by the SWID tag is actually installed on a specific
        ///              computing device
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual System.Boolean? key {
            get {
                XAttribute x = this.Attribute(keyXName);
                if ((x == null)) {
                    return null;
                }
                return XTypedServices.ParseValue<bool>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
            }
            set {
                this.SetAttribute(keyXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              The directory or location where a file was found or can expected
        ///              to be located.  does not include the filename itself.  This can
        ///              be relative path from the 'root' attribute.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string location {
            get {
                XAttribute x = this.Attribute(locationXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(locationXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              The filename without any path characters
        ///            
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string name {
            get {
                XAttribute x = this.Attribute(nameXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(nameXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              A system-specific root folder that the 'location'
        ///              attribute is an offset from. If this is not specified
        ///              the assumption is the 'root' is the same folder as
        ///              the location of the SWIDTAG.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string root {
            get {
                XAttribute x = this.Attribute(rootXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(rootXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<FilesystemItem>(this);
        }
    }
    
    /// <summary>
    /// <para>
    /// Regular expression: (Directory1 | File)*
    /// </para>
    /// </summary>
    public partial class Directory : global::org.iso.standards.swid.FilesystemItem, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName Directory1XName = System.Xml.Linq.XName.Get("Directory", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<Directory> Directory1Field;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName FileXName = System.Xml.Linq.XName.Get("File", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<File> FileField;
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("Directory", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator Directory(XElement xe) { return XTypedServices.ToXTypedElement<Directory>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static Directory() {
            BuildElementDictionary();
            contentModel = new ChoiceContentModelEntity(new NamedContentModelEntity(Directory1XName), new NamedContentModelEntity(FileXName));
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (Directory1 | File)*
        /// </para>
        /// </summary>
        public Directory() {
        }
        
        /// <summary>
        /// <para>
        /// 
        ///                A Directory element allows one or more directories to be
        ///                defined in the file structure.
        ///              
        /// </para>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Regular expression: (Directory1 | File)*
        /// </para>
        /// </summary>
        public virtual IList<Directory> Directory1 {
            get {
                if ((this.Directory1Field == null)) {
                    this.Directory1Field = new XTypedList<Directory>(this, LinqToXsdTypeManager.Instance, Directory1XName);
                }
                return this.Directory1Field;
            }
            set {
                if ((value == null)) {
                    this.Directory1Field = null;
                }
                else {
                    if ((this.Directory1Field == null)) {
                        this.Directory1Field = XTypedList<Directory>.Initialize(this, LinqToXsdTypeManager.Instance, value, Directory1XName);
                    }
                    else {
                        XTypedServices.SetList<Directory>(this.Directory1Field, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///                A File element that allows one or more files to be specified
        ///                for a given location.
        ///              
        /// </para>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Regular expression: (Directory1 | File)*
        /// </para>
        /// </summary>
        public virtual IList<File> File {
            get {
                if ((this.FileField == null)) {
                    this.FileField = new XTypedList<File>(this, LinqToXsdTypeManager.Instance, FileXName);
                }
                return this.FileField;
            }
            set {
                if ((value == null)) {
                    this.FileField = null;
                }
                else {
                    if ((this.FileField == null)) {
                        this.FileField = XTypedList<File>.Initialize(this, LinqToXsdTypeManager.Instance, value, FileXName);
                    }
                    else {
                        XTypedServices.SetList<File>(this.FileField, value);
                    }
                }
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<Directory>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(Directory1XName, typeof(Directory));
            localElementDictionary.Add(FileXName, typeof(File));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    public partial class File : global::org.iso.standards.swid.FilesystemItem, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName sizeXName = System.Xml.Linq.XName.Get("size", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName versionXName = System.Xml.Linq.XName.Get("version", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("File", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd");
        
		public static explicit operator File(XElement xe) { return XTypedServices.ToXTypedElement<File>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public File() {
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              The file size in bytes of the file
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual System.Decimal? size {
            get {
                XAttribute x = this.Attribute(sizeXName);
                if ((x == null)) {
                    return null;
                }
                return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer).Datatype);
            }
            set {
                this.SetAttribute(sizeXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              The file version
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string version {
            get {
                XAttribute x = this.Attribute(versionXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(versionXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<File>(this);
        }
    }
    
    public partial class Process : global::org.iso.standards.swid.Meta, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName nameXName = System.Xml.Linq.XName.Get("name", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName pidXName = System.Xml.Linq.XName.Get("pid", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("Process", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd");
        
		public static explicit operator Process(XElement xe) { return XTypedServices.ToXTypedElement<Process>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public Process() {
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              The process name as it will be found in the devices process
        ///              table.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string name {
            get {
                XAttribute x = this.Attribute(nameXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(nameXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              The process ID for the executing process - note that this will
        ///              typically only be provided when the Process element is included as part
        ///              of Evidence.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual System.Decimal? pid {
            get {
                XAttribute x = this.Attribute(pidXName);
                if ((x == null)) {
                    return null;
                }
                return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer).Datatype);
            }
            set {
                this.SetAttribute(pidXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<Process>(this);
        }
    }
    
    public partial class Resource : global::org.iso.standards.swid.Meta, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName typeXName = System.Xml.Linq.XName.Get("type", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("Resource", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd");
        
		public static explicit operator Resource(XElement xe) { return XTypedServices.ToXTypedElement<Resource>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public Resource() {
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              The type of resource (ie, registrykey, port, rootUrl)
        ///            
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string type {
            get {
                XAttribute x = this.Attribute(typeXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(typeXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<Resource>(this);
        }
    }
    
    /// <summary>
    /// <para>
    /// Regular expression: (Directory | File | Process | Resource)*
    /// </para>
    /// </summary>
    public partial class ResourceCollection : global::org.iso.standards.swid.BaseElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName DirectoryXName = System.Xml.Linq.XName.Get("Directory", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<Directory> DirectoryField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName FileXName = System.Xml.Linq.XName.Get("File", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<File> FileField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName ProcessXName = System.Xml.Linq.XName.Get("Process", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<Process> ProcessField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName ResourceXName = System.Xml.Linq.XName.Get("Resource", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<Resource> ResourceField;
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("ResourceCollection", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
		public static explicit operator ResourceCollection(XElement xe) { return XTypedServices.ToXTypedElement<ResourceCollection>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static ResourceCollection() {
            BuildElementDictionary();
            contentModel = new ChoiceContentModelEntity(new NamedContentModelEntity(DirectoryXName), new NamedContentModelEntity(FileXName), new NamedContentModelEntity(ProcessXName), new NamedContentModelEntity(ResourceXName));
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (Directory | File | Process | Resource)*
        /// </para>
        /// </summary>
        public ResourceCollection() {
        }
        
        /// <summary>
        /// <para>
        /// 
        ///                One or more directory elements
        ///              
        /// </para>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Regular expression: (Directory | File | Process | Resource)*
        /// </para>
        /// </summary>
        public virtual IList<Directory> Directory {
            get {
                if ((this.DirectoryField == null)) {
                    this.DirectoryField = new XTypedList<Directory>(this, LinqToXsdTypeManager.Instance, DirectoryXName);
                }
                return this.DirectoryField;
            }
            set {
                if ((value == null)) {
                    this.DirectoryField = null;
                }
                else {
                    if ((this.DirectoryField == null)) {
                        this.DirectoryField = XTypedList<Directory>.Initialize(this, LinqToXsdTypeManager.Instance, value, DirectoryXName);
                    }
                    else {
                        XTypedServices.SetList<Directory>(this.DirectoryField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///                One or more File elements
        ///              
        /// </para>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Regular expression: (Directory | File | Process | Resource)*
        /// </para>
        /// </summary>
        public virtual IList<File> File {
            get {
                if ((this.FileField == null)) {
                    this.FileField = new XTypedList<File>(this, LinqToXsdTypeManager.Instance, FileXName);
                }
                return this.FileField;
            }
            set {
                if ((value == null)) {
                    this.FileField = null;
                }
                else {
                    if ((this.FileField == null)) {
                        this.FileField = XTypedList<File>.Initialize(this, LinqToXsdTypeManager.Instance, value, FileXName);
                    }
                    else {
                        XTypedServices.SetList<File>(this.FileField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///                One or more Process elements
        ///              
        /// </para>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Regular expression: (Directory | File | Process | Resource)*
        /// </para>
        /// </summary>
        public virtual IList<Process> Process {
            get {
                if ((this.ProcessField == null)) {
                    this.ProcessField = new XTypedList<Process>(this, LinqToXsdTypeManager.Instance, ProcessXName);
                }
                return this.ProcessField;
            }
            set {
                if ((value == null)) {
                    this.ProcessField = null;
                }
                else {
                    if ((this.ProcessField == null)) {
                        this.ProcessField = XTypedList<Process>.Initialize(this, LinqToXsdTypeManager.Instance, value, ProcessXName);
                    }
                    else {
                        XTypedServices.SetList<Process>(this.ProcessField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///                One or more generic resource elements
        ///              
        /// </para>
        /// <para>
        /// Occurrence: required, choice
        /// </para>
        /// <para>
        /// Regular expression: (Directory | File | Process | Resource)*
        /// </para>
        /// </summary>
        public virtual IList<Resource> Resource {
            get {
                if ((this.ResourceField == null)) {
                    this.ResourceField = new XTypedList<Resource>(this, LinqToXsdTypeManager.Instance, ResourceXName);
                }
                return this.ResourceField;
            }
            set {
                if ((value == null)) {
                    this.ResourceField = null;
                }
                else {
                    if ((this.ResourceField == null)) {
                        this.ResourceField = XTypedList<Resource>.Initialize(this, LinqToXsdTypeManager.Instance, value, ResourceXName);
                    }
                    else {
                        XTypedServices.SetList<Resource>(this.ResourceField, value);
                    }
                }
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<ResourceCollection>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(DirectoryXName, typeof(Directory));
            localElementDictionary.Add(FileXName, typeof(File));
            localElementDictionary.Add(ProcessXName, typeof(Process));
            localElementDictionary.Add(ResourceXName, typeof(Resource));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
    }
    
    public partial class Link : global::org.iso.standards.swid.BaseElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName artifactXName = System.Xml.Linq.XName.Get("artifact", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName hrefXName = System.Xml.Linq.XName.Get("href", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName mediaXName = System.Xml.Linq.XName.Get("media", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName ownershipXName = System.Xml.Linq.XName.Get("ownership", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName relXName = System.Xml.Linq.XName.Get("rel", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName typeXName = System.Xml.Linq.XName.Get("type", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName useXName = System.Xml.Linq.XName.Get("use", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("Link", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd");
        
		public static explicit operator Link(XElement xe) { return XTypedServices.ToXTypedElement<Link>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public Link() {
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              For installation media (rel="installationmedia") - dictates the
        ///              canonical name for the file.
        ///
        ///              Items with the same artifact name should be considered mirrors
        ///              of each other (so download from wherever works).
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string artifact {
            get {
                XAttribute x = this.Attribute(artifactXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(artifactXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              The link to the item being referenced.
        ///
        ///              The href can point to several different things, and can be any
        ///              of the following:
        ///
        ///              - a RELATIVE URI (no scheme) - which is interpreted depending on
        ///              context (ie, "./folder/supplemental.swidtag" )
        ///
        ///              - a physical file location with any system-acceptable
        ///              URI scheme (ie, file:// http:// https:// ftp:// ... etc )
        ///
        ///              - an URI with "swid:" as the scheme, which refers to another
        ///              swid by tagId. This URI would need to be resolved in the
        ///              context of the system by software that can lookup other
        ///              swidtags.( ie, "swid:2df9de35-0aff-4a86-ace6-f7dddd1ade4c" )
        ///
        ///              - an URI with "swidpath:" as the scheme, which refers to another
        ///              swid by an XPATH query.  This URI would need to be resolved in
        ///              the context of the system by software that can lookup other
        ///              swidtags, and select the appropriate one based on an XPATH
        ///              query. Examples:
        ///
        ///              swidpath://SoftwareIdentity[Entity/@regid='http://contoso.com']
        ///              would retrieve all swidtags that had an entity where the
        ///              regid was Contoso
        ///
        ///              swidpath://SoftwareIdentity[Meta/@persistentId='b0c55172-38e9-4e36-be86-92206ad8eddb']
        ///              would retrieve swidtags that matched the persistentId
        ///
        ///              See XPATH query standard : http://www.w3.org/TR/xpath20/
        ///            
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual System.Uri href {
            get {
                XAttribute x = this.Attribute(hrefXName);
                return XTypedServices.ParseValue<System.Uri>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyUri).Datatype);
            }
            set {
                this.SetAttribute(hrefXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyUri).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              An attribute defined by the W3C Media Queries Recommendation
        ///              (see http://www.w3.org/TR/css3-mediaqueries/).
        ///
        ///              A hint to the consumer of the link to what the target item is
        ///              applicable for.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string media {
            get {
                XAttribute x = this.Attribute(mediaXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(mediaXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              Determines the relative strength of ownership of the target
        ///              piece of software.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string ownership {
            get {
                XAttribute x = this.Attribute(ownershipXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
            }
            set {
                this.SetAttribute(ownershipXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              The relationship between this SWID and the target file.
        ///
        ///              Relationships can be identified by referencing the IANA
        ///              registration library -
        ///              https://www.iana.org/assignments/link-relations/link-relations.xhtml.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string rel {
            get {
                XAttribute x = this.Attribute(relXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
            }
            set {
                this.SetAttribute(relXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              The IANA MediaType for the target file; this provides the
        ///              consumer with intelligence of what to expect.
        ///
        ///              See http://www.iana.org/assignments/media-types/media-types.xhtml
        ///              for more details on link type.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string type {
            get {
                XAttribute x = this.Attribute(typeXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(typeXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              Determines if the target software is a hard requirement or not
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual org.iso.standards.swid.Use? use {
            get {
                XAttribute x = this.Attribute(useXName);
                if ((x == null)) {
                    return null;
                }
                return ((org.iso.standards.swid.Use)(Enum.Parse(typeof(org.iso.standards.swid.Use), XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype))));
            }
            set {
                this.SetAttribute(useXName, value?.ToString(), XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<Link>(this);
        }
    }
    
    public partial class Meta : global::org.iso.standards.swid.BaseElement, IXMetaData {
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("Meta", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd");
        
		public static explicit operator Meta(XElement xe) { return XTypedServices.ToXTypedElement<Meta>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public Meta() {
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<Meta>(this);
        }
    }
    
    /// <summary>
    /// <para>
    /// Regular expression: (Entity+ | Evidence? | Link* | Meta* | Payload? | any)+
    /// </para>
    /// </summary>
    public partial class SoftwareIdentityType : global::org.iso.standards.swid.BaseElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName EntityXName = System.Xml.Linq.XName.Get("Entity", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<Entity> EntityField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName EvidenceXName = System.Xml.Linq.XName.Get("Evidence", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<Evidence> EvidenceField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName LinkXName = System.Xml.Linq.XName.Get("Link", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<Link> LinkField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName MetaXName = System.Xml.Linq.XName.Get("Meta", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<SoftwareMeta> MetaField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName PayloadXName = System.Xml.Linq.XName.Get("Payload", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<ResourceCollection> PayloadField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName corpusXName = System.Xml.Linq.XName.Get("corpus", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static bool corpusDefaultValue = System.Xml.XmlConvert.ToBoolean("false");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName patchXName = System.Xml.Linq.XName.Get("patch", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static bool patchDefaultValue = System.Xml.XmlConvert.ToBoolean("false");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName mediaXName = System.Xml.Linq.XName.Get("media", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName nameXName = System.Xml.Linq.XName.Get("name", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName supplementalXName = System.Xml.Linq.XName.Get("supplemental", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static bool supplementalDefaultValue = System.Xml.XmlConvert.ToBoolean("false");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName tagIdXName = System.Xml.Linq.XName.Get("tagId", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName tagVersionXName = System.Xml.Linq.XName.Get("tagVersion", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static decimal tagVersionDefaultValue = System.Xml.XmlConvert.ToDecimal("0");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName versionXName = System.Xml.Linq.XName.Get("version", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static string versionDefaultValue = "0.0";
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName versionSchemeXName = System.Xml.Linq.XName.Get("versionScheme", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static string versionSchemeDefaultValue = "multipartnumeric";
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("SoftwareIdentity", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static Dictionary<System.Xml.Linq.XName, System.Type> localElementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static FSM validationStates;
        
		public static explicit operator SoftwareIdentityType(XElement xe) { return XTypedServices.ToXTypedElement<SoftwareIdentityType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static SoftwareIdentityType() {
            BuildElementDictionary();
            InitFSM();
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (Entity+ | Evidence? | Link* | Meta* | Payload? | any)+
        /// </para>
        /// </summary>
        public SoftwareIdentityType() {
        }
        
        /// <summary>
        /// <para>
        /// 
        ///                Specifies the organizations related to the software component
        ///                referenced by this SWID tag.
        ///
        ///                This has a minOccurs of 1 because the spec declares that
        ///                you must have at least a Entity with role='tagCreator'
        ///              
        /// </para>
        /// <para>
        /// Occurrence: required, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (Entity+ | Evidence? | Link* | Meta* | Payload? | any)+
        /// </para>
        /// </summary>
        public virtual IList<Entity> Entity {
            get {
                if ((this.EntityField == null)) {
                    this.EntityField = new XTypedList<Entity>(this, LinqToXsdTypeManager.Instance, EntityXName);
                }
                return this.EntityField;
            }
            set {
                if ((value == null)) {
                    this.EntityField = null;
                }
                else {
                    if ((this.EntityField == null)) {
                        this.EntityField = XTypedList<Entity>.Initialize(this, LinqToXsdTypeManager.Instance, value, EntityXName);
                    }
                    else {
                        XTypedServices.SetList<Entity>(this.EntityField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///                This element is used to provide results from a scan of a
        ///                system where software that does not have a SWID tag is
        ///                discovered.  This information is not provided by the
        ///                software creator, but is instead created when a system
        ///                is being scanned and the evidence for why software is
        ///                believed to be installed on the device is provided in the
        ///                Evidence element.
        ///              
        /// </para>
        /// <para>
        /// Occurrence: optional, choice
        /// </para>
        /// <para>
        /// Regular expression: (Entity+ | Evidence? | Link* | Meta* | Payload? | any)+
        /// </para>
        /// </summary>
        public virtual IList<Evidence> Evidence {
            get {
                if ((this.EvidenceField == null)) {
                    this.EvidenceField = new XTypedList<Evidence>(this, LinqToXsdTypeManager.Instance, EvidenceXName);
                }
                return this.EvidenceField;
            }
            set {
                if ((value == null)) {
                    this.EvidenceField = null;
                }
                else {
                    if ((this.EvidenceField == null)) {
                        this.EvidenceField = XTypedList<Evidence>.Initialize(this, LinqToXsdTypeManager.Instance, value, EvidenceXName);
                    }
                    else {
                        XTypedServices.SetList<Evidence>(this.EvidenceField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///                A reference to any another item (can include details that
        ///                are related to the SWID tag such as details on where software
        ///                downloads can be found, vulnerability database associations,
        ///                use rights, etc).
        ///
        ///                Note:  This is modelled directly to match the HTML [LINK]
        ///                element; it is critical for streamlining software discovery
        ///                scenarios that these are kept consistent.
        ///              
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (Entity+ | Evidence? | Link* | Meta* | Payload? | any)+
        /// </para>
        /// </summary>
        public virtual IList<Link> Link {
            get {
                if ((this.LinkField == null)) {
                    this.LinkField = new XTypedList<Link>(this, LinqToXsdTypeManager.Instance, LinkXName);
                }
                return this.LinkField;
            }
            set {
                if ((value == null)) {
                    this.LinkField = null;
                }
                else {
                    if ((this.LinkField == null)) {
                        this.LinkField = XTypedList<Link>.Initialize(this, LinqToXsdTypeManager.Instance, value, LinkXName);
                    }
                    else {
                        XTypedServices.SetList<Link>(this.LinkField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///                An open-ended collection of key/value data related to this SWID.
        ///              
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (Entity+ | Evidence? | Link* | Meta* | Payload? | any)+
        /// </para>
        /// </summary>
        public virtual IList<SoftwareMeta> Meta {
            get {
                if ((this.MetaField == null)) {
                    this.MetaField = new XTypedList<SoftwareMeta>(this, LinqToXsdTypeManager.Instance, MetaXName);
                }
                return this.MetaField;
            }
            set {
                if ((value == null)) {
                    this.MetaField = null;
                }
                else {
                    if ((this.MetaField == null)) {
                        this.MetaField = XTypedList<SoftwareMeta>.Initialize(this, LinqToXsdTypeManager.Instance, value, MetaXName);
                    }
                    else {
                        XTypedServices.SetList<SoftwareMeta>(this.MetaField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///                The items that may be installed on a device when the software is
        ///                installed.  Note that Payload may be a superset of the items
        ///                installed and, depending on optimization systems for a device,
        ///                may or may not include every item that could be created or
        ///                executed on a device when software is installed.
        ///
        ///                In general, payload will be used to indicate the files that
        ///                may be installed with a software product and will often be a
        ///                superset of those files (i.e. if a particular optional
        ///                component is not installed, the files associated with that
        ///                component may be included in payload, but not installed on
        ///                the device).
        ///              
        /// </para>
        /// <para>
        /// Occurrence: optional, choice
        /// </para>
        /// <para>
        /// Regular expression: (Entity+ | Evidence? | Link* | Meta* | Payload? | any)+
        /// </para>
        /// </summary>
        public virtual IList<ResourceCollection> Payload {
            get {
                if ((this.PayloadField == null)) {
                    this.PayloadField = new XTypedList<ResourceCollection>(this, LinqToXsdTypeManager.Instance, PayloadXName);
                }
                return this.PayloadField;
            }
            set {
                if ((value == null)) {
                    this.PayloadField = null;
                }
                else {
                    if ((this.PayloadField == null)) {
                        this.PayloadField = XTypedList<ResourceCollection>.Initialize(this, LinqToXsdTypeManager.Instance, value, PayloadXName);
                    }
                    else {
                        XTypedServices.SetList<ResourceCollection>(this.PayloadField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (Entity+ | Evidence? | Link* | Meta* | Payload? | any)+
        /// </para>
        /// </summary>
        public virtual IEnumerable<XElement> Any {
            get {
                return this.GetWildCards(WildCard.DefaultWildCard);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              Set to true, if this attribute specifies that this SWID tag is a
        ///              collection of information that describes the pre-installation
        ///              data of software component.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual bool corpus {
            get {
                XAttribute x = this.Attribute(corpusXName);
                return XTypedServices.ParseValue<bool>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype, corpusDefaultValue);
            }
            set {
                this.SetAttribute(corpusXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              Set to true if this SWID describes a product patch or
        ///              modification to a different software element.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual bool patch {
            get {
                XAttribute x = this.Attribute(patchXName);
                return XTypedServices.ParseValue<bool>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype, patchDefaultValue);
            }
            set {
                this.SetAttribute(patchXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              media is a hint to the tag consumer to understand what this
        ///              SWID tag applies to (see the [Link] tags media attribute).
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string media {
            get {
                XAttribute x = this.Attribute(mediaXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(mediaXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              This attribute provides the software component name as it would
        ///              typically be referenced.  For example, what would be seen in the
        ///              add/remove dialog on a Windows device, or what is specified as
        ///              the name of a packaged software product or a patch identifier
        ///              name on a Linux device.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string name {
            get {
                XAttribute x = this.Attribute(nameXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(nameXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              Specifies that this tag provides supplemental tag data that can
        ///              be merged with primary tag data to create a complete record of
        ///              the software information.
        ///
        ///              Supplemental tags will often be provided at install time and may
        ///              be provided by different entities (such as the tag consumer, or
        ///              a Value Added Reseller).
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual bool supplemental {
            get {
                XAttribute x = this.Attribute(supplementalXName);
                return XTypedServices.ParseValue<bool>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype, supplementalDefaultValue);
            }
            set {
                this.SetAttribute(supplementalXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              tagId shall be a globally unique identifier and should be
        ///              assigned a GUID reference (see ISO/IEC 19770-5 definition
        ///              for GUID).
        ///
        ///              The tagID provides a unique reference for the specific product,
        ///              version, edition, revision, etc (essentially, the same binary
        ///              distribution).  If two tagIDs match and the tagCreator is the
        ///              same, the underlying products they represent are expected to be
        ///              exactly the same.
        ///
        ///              This allows IT systems to identify if a software item (for
        ///              example, a patch) is installed simply by referencing the
        ///              specific tagID value which is likely to be readily available
        ///              in a software inventory.
        ///
        ///              It is recommended, when possible, that a 16 byte GUID
        ///              be used for this field as this provides global uniqueness without
        ///              a significant amount of overhead for space.
        ///
        ///              If use of a 16 byte GUID is not possible, a text based globally
        ///              unique ID may be constructed, this ID should include a unique
        ///              naming authority for the tagCreator and sufficient additional
        ///              details that the tagId is unique for the software product,
        ///              version, edition, revision, etc.  This would likely look as
        ///              follows (+ is used as a string concatenation symbol):
        ///
        ///              regid + productName + version + edition + revision + ...
        ///            
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string tagId {
            get {
                XAttribute x = this.Attribute(tagIdXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(tagIdXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              The tagVersion indicates if a specific release of a software
        ///              product has more than one tag that can represent that specific
        ///              release.  This may be the case if a software tag producer creates
        ///              and releases an incorrect tag that they subsequently want to fix,
        ///              but with no underlying changes to the product the SWID tag
        ///              represents.  This could happen if, for example, a patch is
        ///              distributed that has a Link reference that does not cover all the
        ///              various software releases it can patch.  A newer SWID tag for that
        ///              patch can be generated and the tagVersion value incremented to
        ///              indicate that the data is updated.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual decimal tagVersion {
            get {
                XAttribute x = this.Attribute(tagVersionXName);
                return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer).Datatype, tagVersionDefaultValue);
            }
            set {
                this.SetAttribute(tagVersionXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              Underlying development version for the software component.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string version {
            get {
                XAttribute x = this.Attribute(versionXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, versionDefaultValue);
            }
            set {
                this.SetAttribute(versionXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              Scheme used for the version number.  Some possible common values are:
        ///
        ///              value="alphanumeric"
        ///                Strictly a string, sorting alphanumericaly
        ///        
        ///              value="decimal"
        ///                A floating point number : ( ie, 1.25 is less than 1.3 )
        ///        
        ///              value="multipartnumeric"
        ///                Numbers seperated by dots, where the numbers are interpreted as
        ///                integers (ie, 1.2.3 ,  1.4.5.6 , 1.2.3.4.5.6.7 )
        ///        
        ///              value="multipartnumeric+suffix"
        ///                Numbers seperated by dots, where the numbers are interpreted as
        ///                integers with an additional string suffix: (ie, 1.2.3a)
        ///          
        ///              value="semver"
        ///                Follows the semver.org spec
        ///
        ///              value="unknown"
        ///                Unknown, no attempt should be made to order these
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string versionScheme {
            get {
                XAttribute x = this.Attribute(versionSchemeXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype, versionSchemeDefaultValue);
            }
            set {
                this.SetAttribute(versionSchemeXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<SoftwareIdentityType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(EntityXName, typeof(Entity));
            localElementDictionary.Add(EvidenceXName, typeof(Evidence));
            localElementDictionary.Add(LinkXName, typeof(Link));
            localElementDictionary.Add(MetaXName, typeof(SoftwareMeta));
            localElementDictionary.Add(PayloadXName, typeof(ResourceCollection));
        }
        
        FSM IXMetaData.GetValidationStates() {
            return validationStates;
        }
        
        private static void InitFSM() {
            Dictionary<int, Transitions> transitions = new Dictionary<int, Transitions>();
            transitions.Add(1, new Transitions(new SingleTransition(System.Xml.Linq.XName.Get("Entity", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 2), new SingleTransition(System.Xml.Linq.XName.Get("Evidence", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 4), new SingleTransition(System.Xml.Linq.XName.Get("Link", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 5), new SingleTransition(System.Xml.Linq.XName.Get("Meta", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 7), new SingleTransition(System.Xml.Linq.XName.Get("Payload", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 10), new SingleTransition(new WildCard("##other", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 11)));
            transitions.Add(2, new Transitions(new SingleTransition(System.Xml.Linq.XName.Get("Entity", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 2), new SingleTransition(System.Xml.Linq.XName.Get("Evidence", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 4), new SingleTransition(System.Xml.Linq.XName.Get("Link", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 5), new SingleTransition(System.Xml.Linq.XName.Get("Meta", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 7), new SingleTransition(System.Xml.Linq.XName.Get("Payload", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 10), new SingleTransition(new WildCard("##other", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 11)));
            transitions.Add(4, new Transitions(new SingleTransition(System.Xml.Linq.XName.Get("Entity", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 2), new SingleTransition(System.Xml.Linq.XName.Get("Evidence", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 4), new SingleTransition(System.Xml.Linq.XName.Get("Link", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 5), new SingleTransition(System.Xml.Linq.XName.Get("Meta", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 7), new SingleTransition(System.Xml.Linq.XName.Get("Payload", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 10), new SingleTransition(new WildCard("##other", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 11)));
            transitions.Add(5, new Transitions(new SingleTransition(System.Xml.Linq.XName.Get("Link", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 5), new SingleTransition(System.Xml.Linq.XName.Get("Entity", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 2), new SingleTransition(System.Xml.Linq.XName.Get("Evidence", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 4), new SingleTransition(System.Xml.Linq.XName.Get("Meta", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 7), new SingleTransition(System.Xml.Linq.XName.Get("Payload", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 10), new SingleTransition(new WildCard("##other", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 11)));
            transitions.Add(7, new Transitions(new SingleTransition(System.Xml.Linq.XName.Get("Meta", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 7), new SingleTransition(System.Xml.Linq.XName.Get("Entity", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 2), new SingleTransition(System.Xml.Linq.XName.Get("Evidence", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 4), new SingleTransition(System.Xml.Linq.XName.Get("Link", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 5), new SingleTransition(System.Xml.Linq.XName.Get("Payload", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 10), new SingleTransition(new WildCard("##other", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 11)));
            transitions.Add(10, new Transitions(new SingleTransition(System.Xml.Linq.XName.Get("Entity", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 2), new SingleTransition(System.Xml.Linq.XName.Get("Evidence", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 4), new SingleTransition(System.Xml.Linq.XName.Get("Link", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 5), new SingleTransition(System.Xml.Linq.XName.Get("Meta", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 7), new SingleTransition(System.Xml.Linq.XName.Get("Payload", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 10), new SingleTransition(new WildCard("##other", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 11)));
            transitions.Add(11, new Transitions(new SingleTransition(System.Xml.Linq.XName.Get("Entity", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 2), new SingleTransition(System.Xml.Linq.XName.Get("Evidence", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 4), new SingleTransition(System.Xml.Linq.XName.Get("Link", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 5), new SingleTransition(System.Xml.Linq.XName.Get("Meta", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 7), new SingleTransition(System.Xml.Linq.XName.Get("Payload", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 10), new SingleTransition(new WildCard("##other", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), 11)));
            validationStates = new FSM(1, new Set<int>(new int[] {
                            2,
                            1,
                            4,
                            5,
                            7,
                            10,
                            11}), transitions);
        }
    }
    
    public partial class SoftwareMeta : global::org.iso.standards.swid.Meta, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName activationStatusXName = System.Xml.Linq.XName.Get("activationStatus", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName channelTypeXName = System.Xml.Linq.XName.Get("channelType", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName colloquialVersionXName = System.Xml.Linq.XName.Get("colloquialVersion", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName descriptionXName = System.Xml.Linq.XName.Get("description", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName editionXName = System.Xml.Linq.XName.Get("edition", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName entitlementDataRequiredXName = System.Xml.Linq.XName.Get("entitlementDataRequired", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName entitlementKeyXName = System.Xml.Linq.XName.Get("entitlementKey", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName generatorXName = System.Xml.Linq.XName.Get("generator", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName persistentIdXName = System.Xml.Linq.XName.Get("persistentId", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName productXName = System.Xml.Linq.XName.Get("product", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName productFamilyXName = System.Xml.Linq.XName.Get("productFamily", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName revisionXName = System.Xml.Linq.XName.Get("revision", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName summaryXName = System.Xml.Linq.XName.Get("summary", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName unspscCodeXName = System.Xml.Linq.XName.Get("unspscCode", "");
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        internal static readonly System.Xml.Linq.XName unspscVersionXName = System.Xml.Linq.XName.Get("unspscVersion", "");
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("SoftwareMeta", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd");
        
		public static explicit operator SoftwareMeta(XElement xe) { return XTypedServices.ToXTypedElement<SoftwareMeta>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public SoftwareMeta() {
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              Identification of the activation status of this software title
        ///              (e.g. Trial, Serialized, Licensed, Unlicensed, etc).  Typically,
        ///              this is used in supplemental tags.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string activationStatus {
            get {
                XAttribute x = this.Attribute(activationStatusXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(activationStatusXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              Provides information on which channel this particular
        ///              software was targeted for (e.g. Volume, Retail, OEM,
        ///              Academic, etc).  Typically used in supplemental tags.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string channelType {
            get {
                XAttribute x = this.Attribute(channelTypeXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(channelTypeXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              The informal or colloquial version of the product (i.e. 2013).
        ///              Note that this version may be the same through multiple releases
        ///              of a software product where the version specified in
        ///              SoftwareEntity is much more specific and will change for each
        ///              software release.
        ///
        ///              Note that this representation of version is typically used to
        ///              identify a group of specific software releases that are part of
        ///              the same release/support infrastructure
        ///              (i.e. Fabrikam Office 2013).  This version is used for string
        ///              comparisons only and is not compared to be an earlier or later
        ///              release (that is done via the SoftwareEntity version).
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string colloquialVersion {
            get {
                XAttribute x = this.Attribute(colloquialVersionXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(colloquialVersionXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              A longer, detailed description of the software.  This description
        ///              can be multiple sentences (differentiated from summary which is
        ///              a very short, one-sentence description).
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string description {
            get {
                XAttribute x = this.Attribute(descriptionXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(descriptionXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              The variation of the product (Extended, Enterprise, Professional,
        ///              Standard etc)
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string edition {
            get {
                XAttribute x = this.Attribute(editionXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(editionXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              An indicator to determine if there should be accompanying proof
        ///              of entitlement when a software license reconciliation is
        ///              completed.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual System.Boolean? entitlementDataRequired {
            get {
                XAttribute x = this.Attribute(entitlementDataRequiredXName);
                if ((x == null)) {
                    return null;
                }
                return XTypedServices.ParseValue<bool>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
            }
            set {
                this.SetAttribute(entitlementDataRequiredXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Boolean).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              A vendor-specific textual key that can be used to reconcile the
        ///              validity of an entitlement. (e.g. serial number, product or
        ///              license key).
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string entitlementKey {
            get {
                XAttribute x = this.Attribute(entitlementKeyXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(entitlementKeyXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              The name of the software tool that created a SWID tag.  This
        ///              element is typically used if tags are created on the fly, or
        ///              based on a catalogue based analysis for data found on a
        ///              computing device.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string generator {
            get {
                XAttribute x = this.Attribute(generatorXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(generatorXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              A GUID used to represent products installed where the products
        ///              are related, but may be different versions.  See one
        ///              representation of this value through the use of what, in a
        ///              windows installation process is referred to as an upgradeCode
        ///              - http://msdn.microsoft.com/en-us/library/aa372375(v=vs.85).aspx
        ///              as one example of the use of this value.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string persistentId {
            get {
                XAttribute x = this.Attribute(persistentIdXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(persistentIdXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              The base name of the product (e.g. Office, Creative Suites,
        ///              Websphere, etc).
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string product {
            get {
                XAttribute x = this.Attribute(productXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(productXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              The overall product family this software belongs to.  Product
        ///              family is not used to identify that a product is part of a
        ///              suite, but is instead used when a set of products that are all
        ///              related may be installed on multiple different devices.
        ///
        ///              For example, an Enterprise backup system may consist of a backup
        ///              server, multiple different backup systems that support mail
        ///              servers, databases and ERP systems as well as individual software
        ///              items that backup client devices.  In this case all software
        ///              titles that are part of the backup system would have the same
        ///              productFamily name so they can be grouped together in reporting
        ///              systems.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string productFamily {
            get {
                XAttribute x = this.Attribute(productFamilyXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(productFamilyXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              The informal or colloquial representation of the sub-version of
        ///              the given product (ie, SP1, R2, RC1, Beta 2, etc).  Note that the
        ///              SoftwareIdentity.version will provide very exact version details,
        ///              the revision is intended for use in environments where reporting
        ///              on the informal or colloquial representation of the software is
        ///              important (for example, if for a certain business process, an
        ///              organization recognizes that it must have ServicePack 1 or later
        ///              of a specific product installed on all devices, they can use the
        ///              revision data value to quickly identify any devices that do not
        ///              meet this requirement).
        ///
        ///              Depending on how a software organizations distributes revisions,
        ///              this value could be specified in a primary (if distributed as an
        ///              upgrade) or supplemental (if distributed as a patch) SWID tag.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string revision {
            get {
                XAttribute x = this.Attribute(revisionXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(revisionXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              A short (one-sentence) description of the software.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string summary {
            get {
                XAttribute x = this.Attribute(summaryXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(summaryXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              An 8 digit code that provides UNSPSC classification of the
        ///              software product this SWID tag identifies.  For more
        ///              information see, http://www.unspsc.org/
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string unspscCode {
            get {
                XAttribute x = this.Attribute(unspscCodeXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(unspscCodeXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              The version of the UNSPSC code used to define the UNSPSC code
        ///              value. For more information see, http://www.unspsc.org/.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string unspscVersion {
            get {
                XAttribute x = this.Attribute(unspscVersionXName);
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetAttribute(unspscVersionXName, value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<SoftwareMeta>(this);
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///        An expression that the document evaluator can use to determine if the
    ///        target of the link is applicable to the current platform (the host
    ///        environment)
    ///
    ///        Used as an optimization hint to notify a system that it can
    ///        ignore something when it's not likely to be used.
    ///
    ///        The format of this string is modeled upon the MediaQuery definition at
    ///        http://www.w3.org/TR/css3-mediaqueries/
    ///
    ///        This is one or more EXPRESSIONs where the items are connected
    ///        with an OPERATOR:
    ///
    ///        media="EXPRESSION [[OPERATOR] [EXPRESSION]...]"
    ///
    ///        EXPRESSION is processed case-insensitive and defined either :
    ///        (ENVIRONMENT)
    ///        indicates the presence of the environment
    ///        or
    ///        ([PREFIX-]ENVIRONMENT.ATTRIBUTE:VALUE)
    ///        indicates a comparison of an attribute of the environment.
    ///
    ///        ENVIRONMENT is a text identifier that specifies any software,hardware
    ///        feature or aspect of the system the software is intended to run in.
    ///
    ///        Common ENVIRONMENTs include (but not limited to):
    ///        linux
    ///        windows
    ///        java
    ///        powershell
    ///        ios
    ///        chipset
    ///        peripheral
    ///
    ///        ATTRIBUTE is a property of an ENVIRONMENT with a specific value.
    ///        Common attributes include (but not limited to):
    ///        version
    ///        vendor
    ///        architecture
    ///
    ///        PREFIX is defined as one of:
    ///        MIN    # property has a minimum value of VALUE
    ///        MAX    # property has a maximum value of VALUE
    ///
    ///        if a PREFIX is not provided, then the property should equal VALUE
    ///
    ///        OPERATOR is defined of one of:
    ///        AND
    ///        NOT
    ///
    ///        Examples:
    ///        media="(windows)"
    ///        # applies to only systems that identify themselves as 'Windows'
    ///
    ///        media="(windows) not (windows.architecture:x64)"
    ///        # applies to only systems that identify
    ///        # themselves as windows and are not for an x64 cpu
    ///
    ///        media="(windows) and (min-windows.version:6.1)"
    ///        # applies to systems that identify themselves as
    ///        # windows and at least version 6.1
    ///
    ///        media="(linux) and (linux.vendor:redhat) and (min-linux.kernelversion:3.0)"
    ///        # applies to systems that identify themselves as
    ///        # linux, made by redhat and with a kernel version of at least 3.0
    ///
    ///        media="(freebsd) and (min-freebsd.kernelversion:6.6)"
    ///        # applies to systems that identify themselves as
    ///        # freebsd, with a kernel version of at least 6.6
    ///
    ///        media="(powershell) and (min-powershell.version:3.0)"
    ///        # applies to systems that have powershell 3.0 or greater
    ///
    ///        Properties are expected to be able to be resolved by the host
    ///        environment without having to do significant computation.
    ///      
    /// </para>
    /// </summary>
    public sealed class Media {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), null);
        
        private Media() {
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///        The IANA MediaType for the target href; this provides the SWID tag
    ///        consumer with intelligence of what to expect.
    ///
    ///        See http://www.iana.org/assignments/media-types/media-types.xhtml
    ///        for more details on link type.
    ///      
    /// </para>
    /// </summary>
    public sealed class MediaType {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), null);
        
        private MediaType() {
        }
    }
    
    public sealed class Ownership {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                        "abandon",
                        "private",
                        "shared"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
        
        private Ownership() {
        }
    }
    
    /// <summary>
    /// <para>
    /// 
    ///        Determines if the target software is a hard requirement.
    ///      
    /// </para>
    /// </summary>
    public enum Use {
        
        required,
        
        recommended,
        
        optional,
    }
    
    /// <summary>
    /// <para>
    /// 
    ///        Determines if the target software is a hard requirement.
    ///      
    /// </para>
    /// </summary>
    public sealed class UseValidator {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                        "required",
                        "recommended",
                        "optional"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
        
        private UseValidator() {
        }
    }
    
    public partial class SoftwareIdentity : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private SoftwareIdentityType ContentField;
        
        private static readonly System.Xml.Linq.XName xName = System.Xml.Linq.XName.Get("SoftwareIdentity", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd");
        
		public static explicit operator SoftwareIdentity(XElement xe) { return XTypedServices.ToXTypedElement<SoftwareIdentity, SoftwareIdentityType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public SoftwareIdentity() {
            SetInnerType(new SoftwareIdentityType());
        }
        
        public SoftwareIdentity(SoftwareIdentityType content) {
            SetInnerType(content);
        }
        
        public override XElement Untyped {
            get {
                return base.Untyped;
            }
            set {
                base.Untyped = value;
                this.ContentField.Untyped = value;
            }
        }
        
        public virtual SoftwareIdentityType Content {
            get {
                return ContentField;
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///                Specifies the organizations related to the software component
        ///                referenced by this SWID tag.
        ///
        ///                This has a minOccurs of 1 because the spec declares that
        ///                you must have at least a Entity with role='tagCreator'
        ///              
        /// </para>
        /// <para>
        /// Occurrence: required, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (Entity+ | Evidence? | Link* | Meta* | Payload? | any)+
        /// </para>
        /// </summary>
        public virtual IList<Entity> Entity {
            get {
                return this.ContentField.Entity;
            }
            set {
                this.ContentField.Entity = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///                This element is used to provide results from a scan of a
        ///                system where software that does not have a SWID tag is
        ///                discovered.  This information is not provided by the
        ///                software creator, but is instead created when a system
        ///                is being scanned and the evidence for why software is
        ///                believed to be installed on the device is provided in the
        ///                Evidence element.
        ///              
        /// </para>
        /// <para>
        /// Occurrence: optional, choice
        /// </para>
        /// <para>
        /// Regular expression: (Entity+ | Evidence? | Link* | Meta* | Payload? | any)+
        /// </para>
        /// </summary>
        public virtual IList<Evidence> Evidence {
            get {
                return this.ContentField.Evidence;
            }
            set {
                this.ContentField.Evidence = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///                A reference to any another item (can include details that
        ///                are related to the SWID tag such as details on where software
        ///                downloads can be found, vulnerability database associations,
        ///                use rights, etc).
        ///
        ///                Note:  This is modelled directly to match the HTML [LINK]
        ///                element; it is critical for streamlining software discovery
        ///                scenarios that these are kept consistent.
        ///              
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (Entity+ | Evidence? | Link* | Meta* | Payload? | any)+
        /// </para>
        /// </summary>
        public virtual IList<Link> Link {
            get {
                return this.ContentField.Link;
            }
            set {
                this.ContentField.Link = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///                An open-ended collection of key/value data related to this SWID.
        ///              
        /// </para>
        /// <para>
        /// Occurrence: optional, repeating, choice
        /// </para>
        /// <para>
        /// Regular expression: (Entity+ | Evidence? | Link* | Meta* | Payload? | any)+
        /// </para>
        /// </summary>
        public virtual IList<SoftwareMeta> Meta {
            get {
                return this.ContentField.Meta;
            }
            set {
                this.ContentField.Meta = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///                The items that may be installed on a device when the software is
        ///                installed.  Note that Payload may be a superset of the items
        ///                installed and, depending on optimization systems for a device,
        ///                may or may not include every item that could be created or
        ///                executed on a device when software is installed.
        ///
        ///                In general, payload will be used to indicate the files that
        ///                may be installed with a software product and will often be a
        ///                superset of those files (i.e. if a particular optional
        ///                component is not installed, the files associated with that
        ///                component may be included in payload, but not installed on
        ///                the device).
        ///              
        /// </para>
        /// <para>
        /// Occurrence: optional, choice
        /// </para>
        /// <para>
        /// Regular expression: (Entity+ | Evidence? | Link* | Meta* | Payload? | any)+
        /// </para>
        /// </summary>
        public virtual IList<ResourceCollection> Payload {
            get {
                return this.ContentField.Payload;
            }
            set {
                this.ContentField.Payload = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (Entity+ | Evidence? | Link* | Meta* | Payload? | any)+
        /// </para>
        /// </summary>
        public virtual IEnumerable<XElement> Any {
            get {
                return this.ContentField.Any;
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              Set to true, if this attribute specifies that this SWID tag is a
        ///              collection of information that describes the pre-installation
        ///              data of software component.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual bool corpus {
            get {
                return this.ContentField.corpus;
            }
            set {
                this.ContentField.corpus = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              Set to true if this SWID describes a product patch or
        ///              modification to a different software element.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual bool patch {
            get {
                return this.ContentField.patch;
            }
            set {
                this.ContentField.patch = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              media is a hint to the tag consumer to understand what this
        ///              SWID tag applies to (see the [Link] tags media attribute).
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string media {
            get {
                return this.ContentField.media;
            }
            set {
                this.ContentField.media = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              This attribute provides the software component name as it would
        ///              typically be referenced.  For example, what would be seen in the
        ///              add/remove dialog on a Windows device, or what is specified as
        ///              the name of a packaged software product or a patch identifier
        ///              name on a Linux device.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string name {
            get {
                return this.ContentField.name;
            }
            set {
                this.ContentField.name = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              Specifies that this tag provides supplemental tag data that can
        ///              be merged with primary tag data to create a complete record of
        ///              the software information.
        ///
        ///              Supplemental tags will often be provided at install time and may
        ///              be provided by different entities (such as the tag consumer, or
        ///              a Value Added Reseller).
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual bool supplemental {
            get {
                return this.ContentField.supplemental;
            }
            set {
                this.ContentField.supplemental = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              tagId shall be a globally unique identifier and should be
        ///              assigned a GUID reference (see ISO/IEC 19770-5 definition
        ///              for GUID).
        ///
        ///              The tagID provides a unique reference for the specific product,
        ///              version, edition, revision, etc (essentially, the same binary
        ///              distribution).  If two tagIDs match and the tagCreator is the
        ///              same, the underlying products they represent are expected to be
        ///              exactly the same.
        ///
        ///              This allows IT systems to identify if a software item (for
        ///              example, a patch) is installed simply by referencing the
        ///              specific tagID value which is likely to be readily available
        ///              in a software inventory.
        ///
        ///              It is recommended, when possible, that a 16 byte GUID
        ///              be used for this field as this provides global uniqueness without
        ///              a significant amount of overhead for space.
        ///
        ///              If use of a 16 byte GUID is not possible, a text based globally
        ///              unique ID may be constructed, this ID should include a unique
        ///              naming authority for the tagCreator and sufficient additional
        ///              details that the tagId is unique for the software product,
        ///              version, edition, revision, etc.  This would likely look as
        ///              follows (+ is used as a string concatenation symbol):
        ///
        ///              regid + productName + version + edition + revision + ...
        ///            
        /// </para>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public virtual string tagId {
            get {
                return this.ContentField.tagId;
            }
            set {
                this.ContentField.tagId = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              The tagVersion indicates if a specific release of a software
        ///              product has more than one tag that can represent that specific
        ///              release.  This may be the case if a software tag producer creates
        ///              and releases an incorrect tag that they subsequently want to fix,
        ///              but with no underlying changes to the product the SWID tag
        ///              represents.  This could happen if, for example, a patch is
        ///              distributed that has a Link reference that does not cover all the
        ///              various software releases it can patch.  A newer SWID tag for that
        ///              patch can be generated and the tagVersion value incremented to
        ///              indicate that the data is updated.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual decimal tagVersion {
            get {
                return this.ContentField.tagVersion;
            }
            set {
                this.ContentField.tagVersion = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              Underlying development version for the software component.
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string version {
            get {
                return this.ContentField.version;
            }
            set {
                this.ContentField.version = value;
            }
        }
        
        /// <summary>
        /// <para>
        /// 
        ///              Scheme used for the version number.  Some possible common values are:
        ///
        ///              value="alphanumeric"
        ///                Strictly a string, sorting alphanumericaly
        ///        
        ///              value="decimal"
        ///                A floating point number : ( ie, 1.25 is less than 1.3 )
        ///        
        ///              value="multipartnumeric"
        ///                Numbers seperated by dots, where the numbers are interpreted as
        ///                integers (ie, 1.2.3 ,  1.4.5.6 , 1.2.3.4.5.6.7 )
        ///        
        ///              value="multipartnumeric+suffix"
        ///                Numbers seperated by dots, where the numbers are interpreted as
        ///                integers with an additional string suffix: (ie, 1.2.3a)
        ///          
        ///              value="semver"
        ///                Follows the semver.org spec
        ///
        ///              value="unknown"
        ///                Unknown, no attempt should be made to order these
        ///            
        /// </para>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public virtual string versionScheme {
            get {
                return this.ContentField.versionScheme;
            }
            set {
                this.ContentField.versionScheme = value;
            }
        }
        
        Dictionary<System.Xml.Linq.XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                IXMetaData schemaMetaData = ((IXMetaData)(this.Content));
                return schemaMetaData.LocalElementsDictionary;
            }
        }
        
        XTypedElement IXMetaData.Content {
            get {
                return this.Content;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        System.Xml.Linq.XName IXMetaData.SchemaName {
            get {
                return xName;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Element;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public void Save(string xmlFile) {
            XTypedServices.Save(xmlFile, Untyped);
        }
        
        public void Save(System.IO.TextWriter tw) {
            XTypedServices.Save(tw, Untyped);
        }
        
        public void Save(System.Xml.XmlWriter xmlWriter) {
            XTypedServices.Save(xmlWriter, Untyped);
        }
        
        public static SoftwareIdentity Load(string xmlFile) {
            return XTypedServices.Load<SoftwareIdentity, SoftwareIdentityType>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static SoftwareIdentity Load(System.IO.TextReader xmlFile) {
            return XTypedServices.Load<SoftwareIdentity, SoftwareIdentityType>(xmlFile, LinqToXsdTypeManager.Instance);
        }
        
        public static SoftwareIdentity Parse(string xml) {
            return XTypedServices.Parse<SoftwareIdentity, SoftwareIdentityType>(xml, LinqToXsdTypeManager.Instance);
        }
        
        public override XTypedElement Clone() {
            return new SoftwareIdentity(((SoftwareIdentityType)(this.Content.Clone())));
        }
        
        private void SetInnerType(SoftwareIdentityType ContentField) {
            this.ContentField = ((SoftwareIdentityType)(XTypedServices.GetCloneIfRooted(ContentField)));
            XTypedServices.SetName(this, this.ContentField);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
    
    public class LinqToXsdTypeManager : ILinqToXsdTypeManager {
        
        private static Dictionary<System.Xml.Linq.XName, System.Type> typeDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        private static Dictionary<System.Xml.Linq.XName, System.Type> elementDictionary = new Dictionary<System.Xml.Linq.XName, System.Type>();
        
        private static Dictionary<System.Type, System.Type> wrapperDictionary = new Dictionary<System.Type, System.Type>();
        
        private static XmlSchemaSet schemaSet;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static LinqToXsdTypeManager typeManagerSingleton = new LinqToXsdTypeManager();
        
        static LinqToXsdTypeManager() {
            BuildTypeDictionary();
            BuildElementDictionary();
            BuildWrapperDictionary();
        }
        
        private LinqToXsdTypeManager() {
        }
        
        XmlSchemaSet ILinqToXsdTypeManager.Schemas {
            get {
                if ((schemaSet == null)) {
                    XmlSchemaSet tempSet = new XmlSchemaSet();
                    System.Threading.Interlocked.CompareExchange(ref schemaSet, tempSet, null);
                }
                return schemaSet;
            }
            set {
                schemaSet = value;
            }
        }
        
        Dictionary<System.Xml.Linq.XName, System.Type> ILinqToXsdTypeManager.GlobalTypeDictionary {
            get {
                return typeDictionary;
            }
        }
        
        Dictionary<System.Xml.Linq.XName, System.Type> ILinqToXsdTypeManager.GlobalElementDictionary {
            get {
                return elementDictionary;
            }
        }
        
        Dictionary<System.Type, System.Type> ILinqToXsdTypeManager.RootContentTypeMapping {
            get {
                return wrapperDictionary;
            }
        }
        
        public static LinqToXsdTypeManager Instance {
            get {
                return typeManagerSingleton;
            }
        }
        
        private static void BuildTypeDictionary() {
            typeDictionary.Add(System.Xml.Linq.XName.Get("BaseElement", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), typeof(global::org.iso.standards.swid.BaseElement));
            typeDictionary.Add(System.Xml.Linq.XName.Get("Entity", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), typeof(global::org.iso.standards.swid.Entity));
            typeDictionary.Add(System.Xml.Linq.XName.Get("Evidence", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), typeof(global::org.iso.standards.swid.Evidence));
            typeDictionary.Add(System.Xml.Linq.XName.Get("FilesystemItem", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), typeof(global::org.iso.standards.swid.FilesystemItem));
            typeDictionary.Add(System.Xml.Linq.XName.Get("Directory", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), typeof(global::org.iso.standards.swid.Directory));
            typeDictionary.Add(System.Xml.Linq.XName.Get("File", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), typeof(global::org.iso.standards.swid.File));
            typeDictionary.Add(System.Xml.Linq.XName.Get("Process", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), typeof(global::org.iso.standards.swid.Process));
            typeDictionary.Add(System.Xml.Linq.XName.Get("Resource", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), typeof(global::org.iso.standards.swid.Resource));
            typeDictionary.Add(System.Xml.Linq.XName.Get("ResourceCollection", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), typeof(global::org.iso.standards.swid.ResourceCollection));
            typeDictionary.Add(System.Xml.Linq.XName.Get("Link", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), typeof(global::org.iso.standards.swid.Link));
            typeDictionary.Add(System.Xml.Linq.XName.Get("Meta", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), typeof(global::org.iso.standards.swid.Meta));
            typeDictionary.Add(System.Xml.Linq.XName.Get("SoftwareIdentity", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), typeof(global::org.iso.standards.swid.SoftwareIdentityType));
            typeDictionary.Add(System.Xml.Linq.XName.Get("SoftwareMeta", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), typeof(global::org.iso.standards.swid.SoftwareMeta));
        }
        
        private static void BuildElementDictionary() {
            elementDictionary.Add(System.Xml.Linq.XName.Get("SoftwareIdentity", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd"), typeof(global::org.iso.standards.swid.SoftwareIdentity));
        }
        
        private static void BuildWrapperDictionary() {
            wrapperDictionary.Add(typeof(org.iso.standards.swid.SoftwareIdentity), typeof(global::org.iso.standards.swid.SoftwareIdentityType));
        }
        
        protected internal static void AddSchemas(XmlSchemaSet schemas) {
            schemas.Add(schemaSet);
        }
        
        public static System.Type GetRootType() {
            return elementDictionary[System.Xml.Linq.XName.Get("SoftwareIdentity", "http://standards.iso.org/iso/19770/-2/2015/schema.xsd")];
        }
    }
    
    public partial class XRootNamespace {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XDocument doc;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedElement rootObject;
        

		public SoftwareIdentity SoftwareIdentity {  get {return rootObject as SoftwareIdentity; } }
        
        private XRootNamespace() {
        }
        
        public XRootNamespace(SoftwareIdentity root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        
        public virtual XDocument XDocument {
            get {
                return doc;
            }
        }
        
        public virtual XTypedElement Root {
            get {
                return rootObject;
            }
        }
        
        public static XRootNamespace Load(string xmlFile) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(xmlFile);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(string xmlFile, LoadOptions options) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(xmlFile, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(TextReader textReader) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(textReader);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(TextReader textReader, LoadOptions options) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(textReader, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Load(XmlReader xmlReader) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Load(xmlReader);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Parse(string text) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Parse(text);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRootNamespace Parse(string text, LoadOptions options) {
            XRootNamespace root = new XRootNamespace();
            root.doc = XDocument.Parse(text, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public virtual void Save(string fileName) {
            doc.Save(fileName);
        }
        
        public virtual void Save(TextWriter textWriter) {
            doc.Save(textWriter);
        }
        
        public virtual void Save(XmlWriter writer) {
            doc.Save(writer);
        }
        
        public virtual void Save(TextWriter textWriter, SaveOptions options) {
            doc.Save(textWriter, options);
        }
        
        public virtual void Save(string fileName, SaveOptions options) {
            doc.Save(fileName, options);
        }
    }
    
    public partial class XRoot {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XDocument doc;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedElement rootObject;
        

		public global::org.iso.standards.swid.SoftwareIdentity SoftwareIdentity {  get {return rootObject as global::org.iso.standards.swid.SoftwareIdentity; } }
        
        private XRoot() {
        }
        
        public XRoot(global::org.iso.standards.swid.SoftwareIdentity root) {
            this.doc = new XDocument(root.Untyped);
            this.rootObject = root;
        }
        
        public virtual XDocument XDocument {
            get {
                return doc;
            }
        }
        
        public virtual XTypedElement Root {
            get {
                return rootObject;
            }
        }
        
        public static XRoot Load(string xmlFile) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(xmlFile);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Load(string xmlFile, LoadOptions options) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(xmlFile, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Load(TextReader textReader) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(textReader);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Load(TextReader textReader, LoadOptions options) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(textReader, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Load(XmlReader xmlReader) {
            XRoot root = new XRoot();
            root.doc = XDocument.Load(xmlReader);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Parse(string text) {
            XRoot root = new XRoot();
            root.doc = XDocument.Parse(text);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public static XRoot Parse(string text, LoadOptions options) {
            XRoot root = new XRoot();
            root.doc = XDocument.Parse(text, options);
            XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
            if ((typedRoot == null)) {
                throw new LinqToXsdException("Invalid root element in xml document.");
            }
            root.rootObject = typedRoot;
            return root;
        }
        
        public virtual void Save(string fileName) {
            doc.Save(fileName);
        }
        
        public virtual void Save(TextWriter textWriter) {
            doc.Save(textWriter);
        }
        
        public virtual void Save(XmlWriter writer) {
            doc.Save(writer);
        }
        
        public virtual void Save(TextWriter textWriter, SaveOptions options) {
            doc.Save(textWriter, options);
        }
        
        public virtual void Save(string fileName, SaveOptions options) {
            doc.Save(fileName, options);
        }
    }
}
